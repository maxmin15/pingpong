fromcollectionsimportdeque
fromimutils.videoimportVideoStream
importnumpyasnp
importargparse
importcv2
importimutils
importtime

#constructtheargumentparseandparsethearguments
ap=argparse.ArgumentParser()
ap.add_argument("-v","--video",
help="pathtothe(optional)videofile")
ap.add_argument("-b","--buffer",type=int,default=64,
help="maxbuffersize")
args=vars(ap.parse_args())

#definethelowerandupperboundariesofthe"green"
#ballintheHSVcolorspace,theninitializethe
#listoftrackedpoints
greenLower=(11,100,141)
greenUpper=(30,255,255)
pts=deque(maxlen=args["buffer"])

#ifavideopathwasnotsupplied,grabthereference
#tothewebcam
ifnotargs.get("video",False):
vs=VideoStream(src=0).start()

#otherwise,grabareferencetothevideofile
else:
vs=cv2.VideoCapture(args["video"])

#allowthecameraorvideofiletowarmup
time.sleep(2.0)

#keeplooping
whileTrue:
#grabthecurrentframe
frame=vs.read()

#handletheframefromVideoCaptureorVideoStream
frame=frame[1]ifargs.get("video",False)elseframe

#ifweareviewingavideoandwedidnotgrabaframe,
#thenwehavereachedtheendofthevideo
ifframeisNone:
break

#resizetheframe,blurit,andconvertittotheHSV
#colorspace
frame=imutils.resize(frame,width=600)
blurred=cv2.GaussianBlur(frame,(3,3),0)
hsv=cv2.cvtColor(blurred,cv2.COLOR_BGR2HSV)

#constructamaskforthecolor"green",thenperform
#aseriesofdilationsanderosionstoremoveanysmall
#blobsleftinthemask
mask=cv2.inRange(hsv,greenLower,greenUpper)
mask=cv2.erode(mask,None,iterations=2)
mask=cv2.dilate(mask,None,iterations=2)

#findcontoursinthemaskandinitializethecurrent
#(x,y)centeroftheball
cnts=cv2.findContours(mask.copy(),cv2.RETR_EXTERNAL,
cv2.CHAIN_APPROX_SIMPLE)
cnts=imutils.grab_contours(cnts)
center=None

#onlyproceedifatleastonecontourwasfound
iflen(cnts)>0:
#findthelargestcontourinthemask,thenuse
#ittocomputetheminimumenclosingcircleand
#centroid
c=max(cnts,key=cv2.contourArea)
((x,y),radius)=cv2.minEnclosingCircle(c)
M=cv2.moments(c)
center=(int(M["m10"]/M["m00"]),int(M["m01"]/M["m00"]))

#onlyproceediftheradiusmeetsaminimumsize
ifradius>10:
#drawthecircleandcentroidontheframe,
#thenupdatethelistoftrackedpoints
cv2.circle(frame,(int(x),int(y)),int(radius),
(0,255,255),2)
cv2.circle(frame,center,5,(0,0,255),-1)

#updatethepointsqueue
pts.appendleft(center)

#loopoverthesetoftrackedpoints
foriinrange(1,len(pts)):
#ifeitherofthetrackedpointsareNone,ignore
#them
ifpts[i-1]isNoneorpts[i]isNone:
continue

#otherwise,computethethicknessofthelineand
#drawtheconnectinglines
thickness=int(np.sqrt(args["buffer"]/float(i+1))*2.5)
cv2.line(frame,pts[i-1],pts[i],(0,0,255),thickness)

#showtheframetoourscreen
cv2.imshow("Frame",frame)
key=cv2.waitKey(1)&0xFF

#ifthe'q'keyispressed,stoptheloop
ifkey==ord("q"):
break

#ifwearenotusingavideofile,stopthecameravideostream
ifnotargs.get("video",False):
vs.stop()

#otherwise,releasethecamera
else:
vs.release()

#closeallwindows
cv2.destroyAllWindows()
